#import "BaseEscrow.jsligo" "BaseEscrow"
#import "./libraries/UniversalTransfer.jsligo" "UniversalTransfer"
#import "./libraries/Immutables.jsligo" "Immutables"



export namespace EscrowManager {

    
    
    // type escrow_maps:
    //  big_map<BaseEscrow.BaseEscrow.unique_escrow_id, BaseEscrow.BaseEscrow.escrow_state>; // escrow address

    type escrow_content = {
        escrow_state: BaseEscrow.BaseEscrow.escrow_state,
        escrow_type: BaseEscrow.BaseEscrow.escrow_type,
        rescue_delay: int
    }
    
    export type escrow_map =
    big_map<BaseEscrow.BaseEscrow.immutables_hash, escrow_content>;


    export type storage = {
        escrow_map: escrow_map
    }
    type return_type = [list<operation>, storage];

    type create_src_params = {
        immutables: Immutables.Immutables.immutables,
        rescue_delay: int
    }

    type create_dst_params = {
        immutables: Immutables.Immutables.immutables,
        rescue_delay: int,
        src_cancellation_timestamp: timestamp
    }

    type rescue_funds_param = {
        immutables: Immutables.Immutables.immutables,
        rescueDelay: int,
        token_opt: option<address>,
        amount: nat
    };


     // Events 
    type escrow_src_created_event = {
        immutables: Immutables.Immutables.immutables,
    };

    type escrow_dst_created_event = {
        immutables: Immutables.Immutables.immutables,
    };

    type escrow_withdraw_event = {
        secret: bytes,
    };

    type escrow_cancel_event = unit


    // rescueFunds event payload
    type funds_rescued_event = {
        rescued_by: address,
        token_rescued: option<address>,
        amount_rescued: nat
    };

    
    const escrow_exists_and_is_active = (escrow_map: escrow_map, escrow_id: BaseEscrow.BaseEscrow.immutables_hash): bool => {

        const escrow_content_opt: option<escrow_content> = Big_map.find_opt (escrow_id, escrow_map);

        return match(escrow_content_opt) {
            when(Some({escrow_state, escrow_type, rescue_delay})): do {
                match(escrow_state) {
                    when(Active): true
                    when(_): false
                }
            }
            when(None): failwith("No Escrows exist that match the immutables hash")
        }
    }

    @view
    const escrow_exists = (immutables: Immutables.Immutables.immutables, store: storage): bool => {
        const escrow_id: BaseEscrow.BaseEscrow.immutables_hash = Immutables.Immutables.hash(immutables);

        const is_active: bool = escrow_exists_and_is_active(store.escrow_map, escrow_id);
        return is_active;
    }

    const onlyValidImmutables = (im: Immutables.Immutables.immutables, escrow_map: escrow_map): unit => {
        
        // escrow hash here is the hash of the immutables
        const escrow_id: BaseEscrow.BaseEscrow.immutables_hash = Immutables.Immutables.hash(im);
        const is_active: bool = escrow_exists_and_is_active(escrow_map, escrow_id);

        if (!is_active) {
            failwith("No Active Escrows exist that match the immutables hash");
        }
    
    }



    export namespace EscrowSrcOperations {

        // Orchatrates the redraw and returns the operations that have to do with withdraw, secret emmision and fund transfer 
        // and then returns the new state of the escrow, which should be finalised now.
        const _src_withdraw_to = (params: {secret: bytes, target: address, immutables: Immutables.Immutables.immutables}, escrow_map: escrow_map): [list<operation>, escrow_map] => {
        
            BaseEscrow.BaseEscrow.onlyValidSecret(params.secret, params.immutables);
            onlyValidImmutables(params.immutables, escrow_map);

            // sends back the token to the target (tez or fa2)
            const token_transfer_op: operation = UniversalTransfer.UniversalTransfer.uniTransfer(
                params.immutables.token,
                Tezos.get_self_address(),
                params.target,
                params.immutables.amount
            );
            

            //
            // send back the safety deposit to the maker of the transaction instead of the taker 
            // but only if we arent yet in public withdrawal
            // this is because on the tezos src side its only the maker that will always create the src escrow
            // because Tezos fa2 tokens dont have full support for thier version of permit 2
         

            const safety_reciever: address =
            (params.immutables.timelocks.srcPublicWithdrawal > Tezos.get_now())
                ? params.immutables.maker
                : Tezos.get_sender();
    
            const safety_deposit_transfer_op: operation = UniversalTransfer.UniversalTransfer.uniTransfer(
                None(),
                Tezos.get_self_address(),
                safety_reciever,
                params.immutables.safetyDeposit
            );

            const escrow_withdraw_event: escrow_withdraw_event = {
                secret: params.secret,
            };

            const event_op: operation = Tezos.Next.Operation.emit("%EscrowWithdrawSrc", escrow_withdraw_event);


            // Update the escrow state to finalized in big map
            // a successfull withdrawal has occured
            const escrow_id: BaseEscrow.BaseEscrow.immutables_hash = Immutables.Immutables.hash(params.immutables);
            
           
            const old_escrow_content_opt: option<escrow_content> = Big_map.find_opt (escrow_id, escrow_map);
            const old_escrow_content = match(old_escrow_content_opt) {
                   when(Some(content)): content
                   when(None): failwith("INTERNAL_ERROR: Escrow disappeared mid-execution")
               };
            
            // Create the new content record by updating only the state field.
            const new_escrow_content: escrow_content = 
               {   
                  escrow_state: Finalized(),
                  escrow_type: old_escrow_content.escrow_type,
                  rescue_delay: old_escrow_content.rescue_delay
               }


            const new_escrow_map: escrow_map = Big_map.update (escrow_id, Some(new_escrow_content), escrow_map);
            
            return [list([token_transfer_op, safety_deposit_transfer_op, event_op]), new_escrow_map];
        }
        
        
        export const src_withdraw_to = (params: {secret: bytes, target: address, immutables: Immutables.Immutables.immutables}, escrow_map: escrow_map): return_type => {

            BaseEscrow.BaseEscrow.onlyTaker(params.immutables);
            BaseEscrow.BaseEscrow.onlyAfter(params.immutables.timelocks.srcWithdrawal);
            BaseEscrow.BaseEscrow.onlyBefore(params.immutables.timelocks.srcCancellation);
            
            const [ops, new_escrow_map]: [list<operation>, escrow_map] = _src_withdraw_to(params, escrow_map);
            return [ops, {escrow_map: new_escrow_map}];
        }

        export const src_withdraw = (params: {secret: bytes, immutables: Immutables.Immutables.immutables}, escrow_map: escrow_map): return_type => {
        

            BaseEscrow.BaseEscrow.onlyTaker(params.immutables);
            BaseEscrow.BaseEscrow.onlyAfter(params.immutables.timelocks.srcWithdrawal);
            BaseEscrow.BaseEscrow.onlyBefore(params.immutables.timelocks.srcCancellation);
            
            const target: address = Tezos.get_sender();
            const new_params: {secret: bytes, target: address, immutables: Immutables.Immutables.immutables} = {secret: params.secret, target: target, immutables: params.immutables};
            const [ops, new_escrow_map]: [list<operation>, escrow_map] = _src_withdraw_to(new_params, escrow_map);

            return [ops, {escrow_map: new_escrow_map}];
            // emit Withdrawal(secret);
            
        }

        export const src_public_withdraw = (params: {secret: bytes, immutables: Immutables.Immutables.immutables}, escrow_map: escrow_map): return_type => {
            
            BaseEscrow.BaseEscrow.onlyAfter(params.immutables.timelocks.srcPublicWithdrawal);
            BaseEscrow.BaseEscrow.onlyBefore(params.immutables.timelocks.srcCancellation);

            const target: address = Tezos.get_sender();
            const new_params: {secret: bytes, target: address, immutables: Immutables.Immutables.immutables} = {secret: params.secret, target: target, immutables: params.immutables};
            const [ops, new_escrow_map]: [list<operation>, escrow_map] =_src_withdraw_to(new_params, escrow_map);

            return [ops, {escrow_map: new_escrow_map}];    

        }

        const _src_cancel = (params: {immutables: Immutables.Immutables.immutables}, escrow_map: escrow_map): [list<operation>, escrow_map] => {
        
            onlyValidImmutables(params.immutables, escrow_map);

            // sends back the token to the target (tez or fa2)
            const token_transfer_op: operation = UniversalTransfer.UniversalTransfer.uniTransfer(
                params.immutables.token,
                Tezos.get_self_address(),
                params.immutables.maker,
                params.immutables.amount
            );

            // sends back the safety deposit to the person who cancelled the escrow
            const safety_deposit_transfer_op: operation = UniversalTransfer.UniversalTransfer.uniTransfer(
                None(),
                Tezos.get_self_address(),
                Tezos.get_sender(),
                params.immutables.safetyDeposit
            );


            const event_op: operation = Tezos.Next.Operation.emit("%EscrowCancelSrc", unit);

            // Once a cancellation has occured, the escrow should no longer be active
            // Update the escrow state to cancelled in big map
            const escrow_id: BaseEscrow.BaseEscrow.immutables_hash = Immutables.Immutables.hash(params.immutables);
            const old_escrow_content_opt: option<escrow_content> = Big_map.find_opt (escrow_id, escrow_map);
            const old_escrow_content = match(old_escrow_content_opt) {
                   when(Some(content)): content
                   when(None): failwith("INTERNAL_ERROR: Escrow disappeared mid-execution")
               };
            
            // Create the new content record by updating only the state field.
            const new_escrow_content: escrow_content = 
               {   
                  escrow_state: Cancelled(),
                  escrow_type: old_escrow_content.escrow_type,
                  rescue_delay: old_escrow_content.rescue_delay
               }


            const new_escrow_map: escrow_map = Big_map.update (escrow_id, Some(new_escrow_content), escrow_map);
            
            return [list([token_transfer_op, safety_deposit_transfer_op, event_op]), new_escrow_map];
        }

        export const src_cancel = (params: {immutables: Immutables.Immutables.immutables}, escrow_map: escrow_map): return_type => {

            BaseEscrow.BaseEscrow.onlyTaker(params.immutables);
            BaseEscrow.BaseEscrow.onlyAfter(params.immutables.timelocks.srcCancellation);

            const [ops, new_escrow_map]: [list<operation>, escrow_map] = _src_cancel(params, escrow_map);
            return [ops, {escrow_map: new_escrow_map}];
        }

        export const src_public_cancel = (params: {immutables: Immutables.Immutables.immutables}, escrow_map: escrow_map): return_type => {

            BaseEscrow.BaseEscrow.onlyAfter(params.immutables.timelocks.srcPublicCancellation);

            const [ops, new_escrow_map]: [list<operation>, escrow_map] = _src_cancel(params, escrow_map);
            return [ops, {escrow_map: new_escrow_map}];
        }
    }

    export namespace EscrowDstOperations {

        const _dst_withdraw = (params: {secret: bytes, immutables: Immutables.Immutables.immutables}, escrow_map: escrow_map): [list<operation>, escrow_map] => {

            BaseEscrow.BaseEscrow.onlyValidSecret(params.secret, params.immutables);
            onlyValidImmutables(params.immutables, escrow_map);

            // sends the requested amount to the maker
            const token_transfer_op: operation = UniversalTransfer.UniversalTransfer.uniTransfer(
                params.immutables.token,
                Tezos.get_self_address(),
                params.immutables.maker,
                params.immutables.amount
            );

            // sends back the safety deposit to the taker
            const safety_deposit_transfer_op: operation = UniversalTransfer.UniversalTransfer.uniTransfer(
                None(),
                Tezos.get_self_address(),
                Tezos.get_sender(),
                params.immutables.safetyDeposit
            );

           
            const escrow_withdraw_event: escrow_withdraw_event = {
                secret: params.secret,
            };

            const event_op: operation = Tezos.Next.Operation.emit("%EscrowWithdrawDst", escrow_withdraw_event);


             // Update the escrow state to finalized in big map
            // a successfull withdrawal has occured
            const escrow_id: BaseEscrow.BaseEscrow.immutables_hash = Immutables.Immutables.hash(params.immutables);
            
           
            const old_escrow_content_opt: option<escrow_content> = Big_map.find_opt (escrow_id, escrow_map);
            const old_escrow_content = match(old_escrow_content_opt) {
                   when(Some(content)): content
                   when(None): failwith("INTERNAL_ERROR: Escrow disappeared mid-execution")
               };
            
            // Create the new content record by updating only the state field.
            const new_escrow_content: escrow_content = 
               {   
                  escrow_state: Finalized(),
                  escrow_type: old_escrow_content.escrow_type,
                  rescue_delay: old_escrow_content.rescue_delay
               }


            const new_escrow_map: escrow_map = Big_map.update (escrow_id, Some(new_escrow_content), escrow_map);
            

            return [ list([token_transfer_op, safety_deposit_transfer_op, event_op]), new_escrow_map];
        }

        export const dst_withdraw = (params: {secret: bytes, immutables: Immutables.Immutables.immutables}, escrow_map: escrow_map): return_type => {

            BaseEscrow.BaseEscrow.onlyTaker(params.immutables);
            BaseEscrow.BaseEscrow.onlyAfter(params.immutables.timelocks.dstWithdrawal);
            BaseEscrow.BaseEscrow.onlyBefore(params.immutables.timelocks.dstCancellation);

            const [ops, new_escrow_map]: [list<operation>, escrow_map] = _dst_withdraw(params, escrow_map);
            return [ops, {escrow_map: new_escrow_map}];
        }

        export const dst_public_withdraw = (params: {secret: bytes, immutables: Immutables.Immutables.immutables }, escrow_map: escrow_map): return_type => {

            BaseEscrow.BaseEscrow.onlyAfter(params.immutables.timelocks.dstPublicWithdrawal);
            BaseEscrow.BaseEscrow.onlyBefore(params.immutables.timelocks.dstCancellation);

            const [ops, new_escrow_map]: [list<operation>, escrow_map] = _dst_withdraw(params, escrow_map);
            return [ops, {escrow_map: new_escrow_map}];
        }

        export const dst_cancel = (params: {immutables: Immutables.Immutables.immutables}, escrow_map: escrow_map): return_type => {

            BaseEscrow.BaseEscrow.onlyTaker(params.immutables);
            onlyValidImmutables(params.immutables, escrow_map);
            BaseEscrow.BaseEscrow.onlyAfter(params.immutables.timelocks.dstCancellation);

            const token_transfer_op: operation = UniversalTransfer.UniversalTransfer.uniTransfer(
                params.immutables.token,
                Tezos.get_self_address(),
                params.immutables.taker,
                params.immutables.amount
            );

            const safety_deposit_transfer_op: operation = UniversalTransfer.UniversalTransfer.uniTransfer(
                None(),
                Tezos.get_self_address(),
                Tezos.get_sender(),
                params.immutables.safetyDeposit
            );

            const event_op: operation = Tezos.Next.Operation.emit("%EscrowCancelDst", unit);

            // Once a cancellation has occured, the escrow should no longer be active
            // Update the escrow state to cancelled in big map
            const escrow_id: BaseEscrow.BaseEscrow.immutables_hash = Immutables.Immutables.hash(params.immutables);
            
           
            const old_escrow_content_opt: option<escrow_content> = Big_map.find_opt (escrow_id, escrow_map);
            const old_escrow_content = match(old_escrow_content_opt) {
                   when(Some(content)): content
                   when(None): failwith("INTERNAL_ERROR: Escrow disappeared mid-execution")
               };
            
            // Create the new content record by updating only the state field.
            const new_escrow_content: escrow_content = 
               {   
                  escrow_state: Cancelled(),
                  escrow_type: old_escrow_content.escrow_type,
                  rescue_delay: old_escrow_content.rescue_delay
               }


            const new_escrow_map: escrow_map = Big_map.update (escrow_id, Some(new_escrow_content), escrow_map);
            
            return [list([token_transfer_op, safety_deposit_transfer_op, event_op]), {escrow_map: new_escrow_map}];
        }
        
    }


    const _createSrcEscrow = (params: create_src_params, store: storage): return_type => {
        
        const immutables_hash: bytes = Immutables.Immutables.hash(params.immutables);

        const escrow_state: BaseEscrow.BaseEscrow.escrow_state = Active();
        const escrow_type: BaseEscrow.BaseEscrow.escrow_type = Source();

        
        const rescue_delay: int = params.rescue_delay;
        const new_escrow_map: escrow_map = Big_map.add(immutables_hash, {escrow_state, escrow_type, rescue_delay}, store.escrow_map);
        const new_store: storage = {escrow_map: new_escrow_map};

        const tez_sent: bool =  match(params.immutables.token) {
            when(Some(token)): do {
                // we only need to check that safety deposit is sent no additional amount is needed in tez
                const safety_deposit: tez = params.immutables.safetyDeposit * 1mutez;
                const deposit_sent: tez = Tezos.get_amount();

                if (deposit_sent != safety_deposit) {
                    failwith("Incorrect amount of safety deposit sent");
                }
                return false
            }

            when(None): do {
                // check that the appropiate amount of tez is sent when fund to be escrowed is tez

                const safety_deposit: tez = params.immutables.safetyDeposit * 1mutez;
                const tez_amount: tez = params.immutables.amount * 1mutez;
                const total_amount: tez = safety_deposit + tez_amount;

                const tez_sent: tez = Tezos.get_amount();
                if (tez_sent != total_amount) {
                    failwith("Incorrect amount of tez sent");
                }
                return true
            }
        }
        
         const escrow_src_created_event: escrow_src_created_event = {
            immutables: params.immutables
        };

        // 6. Create the Event Operation
        // We use a tag that clearly identifies the event, as per convention.
        const event_op: operation = Tezos.Next.Operation.emit("%EscrowSrcCreated", escrow_src_created_event);
        

        if (!tez_sent) {
            // If the token is an fa2(erc20) the contract needs to be approved to send the token
            // to itself
            const transfer_op: operation = UniversalTransfer.UniversalTransfer.uniTransfer(
                params.immutables.token,
                Tezos.get_sender(), // The maker sends the token on escrow creation
                Tezos.get_self_address(),
                params.immutables.amount
            );

            return [list([transfer_op, event_op]), new_store];
        }
        // maker sends funds to escrow and then contract broadcasts escrow creation
        return [list([event_op]), new_store];
    }

    const _createDstEscrow = (params: create_dst_params, store: storage): return_type => {

        // check that safety deposit is sent
        // then check if the amount to be escrowed is tez or fa2

        const tez_sent: bool =  match(params.immutables.token) {
            when(Some(token)): do {
                // we only need to check that safety deposit is sent no additional amount is needed in tez
                const safety_deposit: tez = params.immutables.safetyDeposit * 1mutez;
                const deposit_sent: tez = Tezos.get_amount();

                if (deposit_sent != safety_deposit) {
                    failwith("Incorrect amount of safety deposit sent");
                }
                return false
            }

            when(None): do {
                // check that the appropiate amount of tez is sent when fund to be escrowed is tez

                const safety_deposit: tez = params.immutables.safetyDeposit * 1mutez;
                const tez_amount: tez = params.immutables.amount * 1mutez;
                const total_amount: tez = safety_deposit + tez_amount;

                const tez_sent: tez = Tezos.get_amount();
                if (tez_sent != total_amount) {
                    failwith("Incorrect amount of tez sent");
                }
                return true
            }
        }

        // set deployed timestamp

        const new_timelocks = {...params.immutables.timelocks, deployedAt: Tezos.get_now()};
        const dest_immutables = {...params.immutables, timelocks: new_timelocks};


        // check that the escrow cancellation will start not later than the cancellation time on the source chain.
        if (params.immutables.timelocks.dstCancellation > params.src_cancellation_timestamp) {
            failwith("Invalid creation time");
        }   


        // create a new escrow entry and update contract state
        const escrow_id: BaseEscrow.BaseEscrow.immutables_hash = Immutables.Immutables.hash(dest_immutables);

        const escrow_state: BaseEscrow.BaseEscrow.escrow_state = Active();
        const escrow_type: BaseEscrow.BaseEscrow.escrow_type = Destination();

        const rescue_delay: int = params.rescue_delay;

        const new_escrow_map: escrow_map = Big_map.add(escrow_id, {escrow_state, escrow_type, rescue_delay}, store.escrow_map);
        const new_store: storage = {escrow_map: new_escrow_map};
        
        const escrow_dst_created_event: escrow_dst_created_event = {
            immutables: dest_immutables,
        };
        
        const event_op: operation = Tezos.Next.Operation.emit("%EscrowDstCreated", escrow_dst_created_event);

        if (!tez_sent) {
            // If the token is an fa2(erc20) the contract needs to be approved to send the token
            // to itself
            const transfer_op: operation = UniversalTransfer.UniversalTransfer.uniTransfer(
                params.immutables.token,
                Tezos.get_sender(), // The maker sends the token on escrow creation
                Tezos.get_self_address(),
                params.immutables.amount
            );        
            return [list([transfer_op, event_op]), new_store];
        }
        
        return [list([event_op]), new_store];
    }
    
    
    

    const _rescueFunds = (param: rescue_funds_param, escrow_map: escrow_map): list<operation> => {
        // 1. Modifier equivalent: onlyTaker
        BaseEscrow.BaseEscrow.onlyTaker(param.immutables);

        // 2. Modifier equivalent: onlyValidImmutables
        onlyValidImmutables(param.immutables, escrow_map);

        // 3. Modifier equivalent: onlyAfter
        const rescueStartTime: timestamp = param.immutables.timelocks.deployedAt + param.rescueDelay;      
        BaseEscrow.BaseEscrow.onlyAfter(rescueStartTime);

        // 4. Main logic: Create the transfer operation
        const transfer_op: operation = UniversalTransfer.UniversalTransfer.uniTransfer(
            param.token_opt,
            Tezos.get_self_address(), // from: this contract
            Tezos.get_sender(),       // to: the taker who called this function
            param.amount
        );

        
        const event_payload: funds_rescued_event = {
            rescued_by: Tezos.get_sender(),
            token_rescued: param.token_opt,
            amount_rescued: param.amount
        };

        const event_op: operation = Tezos.Next.Operation.emit("%FundsRescued", event_payload);
        
        // 7. Return BOTH operations in a list
        return list([transfer_op, event_op]);
    }


    @entry
    const createSrcEscrow = (params: create_src_params, store: storage): return_type => {
        return _createSrcEscrow(params, store);
    }

    @entry
    const createDstEscrow = (params: create_dst_params, store: storage): return_type => {
        return _createDstEscrow(params, store);
    }

    @entry
    const rescueFunds = (params: rescue_funds_param, store:storage): return_type => {
        const ops = _rescueFunds(params, store.escrow_map);
        return [ops, store]
    }

    @entry
    const srcWithdraw = (params: {secret: bytes, immutables: Immutables.Immutables.immutables}, store: storage): return_type => {
        return EscrowSrcOperations.src_withdraw(params, store.escrow_map);
        
    }

    @entry
    const srcWithdrawTo = (params: {secret: bytes, target: address, immutables: Immutables.Immutables.immutables}, store: storage): return_type => {
        return EscrowSrcOperations.src_withdraw_to(params, store.escrow_map);
    }

    @entry
    const srcPublicWithdraw = (params: {secret: bytes, immutables: Immutables.Immutables.immutables}, store: storage): return_type => {
        return EscrowSrcOperations.src_public_withdraw(params, store.escrow_map);
    }

    @entry
    const srcCancel = (params: {immutables: Immutables.Immutables.immutables}, store: storage): return_type => {
        return EscrowSrcOperations.src_cancel(params, store.escrow_map);

    }

    @entry
    const dstWithdraw = (params: {secret: bytes, immutables: Immutables.Immutables.immutables}, store: storage): return_type => {
        return EscrowDstOperations.dst_withdraw(params, store.escrow_map);
    }
    
    @entry
    const dstPublicWithdraw = (params: {secret: bytes, immutables: Immutables.Immutables.immutables}, store: storage): return_type => {
        return EscrowDstOperations.dst_public_withdraw(params, store.escrow_map);
    }

    @entry
    const dstCancel = (params: {immutables: Immutables.Immutables.immutables}, store: storage): return_type => {
        return EscrowDstOperations.dst_cancel(params, store.escrow_map);
    }
    


}