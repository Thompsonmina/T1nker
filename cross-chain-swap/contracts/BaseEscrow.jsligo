#import "Immutables.jsligo" "Immutables"
#import "TimeLocksLib.jsligo" "TimeLocksLib"
#import "UniversalTransfer.jsligo" "UniversalTransfer"

// implements IBaseEscrow
export namespace BaseEscrow  {

    
    // rescueFunds parameters
    type rescue_funds_param = {
        immutables: Immutables.Immutables.immutables,
        rescueDelay: int,
        token_opt: option<address>,
        amount: nat
    };

    // rescueFunds event payload
    type funds_rescued_event = {
        rescued_by: address,
        token_rescued: option<address>,
        amount_rescued: nat
    };

    
    const onlyTaker = (im: Immutables.Immutables.immutables) : unit => {
        if (Tezos.get_sender() != im.taker) {
            failwith("NOT_TAKER");   // abort the transaction
        };
    };

    // const onlyValidImmutables = (im: Immutables.Immutables.immutables) : unit => {
    //     // todo: implement
    // }

    // modifier onlyValidImmutables(Immutables calldata immutables) virtual {
    //     _validateImmutables(immutables);
    //     _;
    // }

    // /**
    //  * @dev Should verify that the computed escrow address matches the address of this contract.
    //  */
    // function _validateImmutables(Immutables calldata immutables) internal view virtual;

    const onlyValidSecret = (secret: bytes, immutables: Immutables.Immutables.immutables) : unit => {
        if (Crypto.keccak(secret) != immutables.hashlock) {
            failwith("INVALID_SECRET");
        };
    }

    const onlyAfter = (start: timestamp) : unit => {
        if (Tezos.get_now() < start) {
            failwith("INVALID_TIME");
        };
    }
        
    const onlyBefore = (stop: timestamp) : unit => {
        if (Tezos.get_now() >= stop) {
            failwith("INVALID_TIME");
        };
    }

    // Checks if a secret matches the hashlock by comparing their keccak hashes
    const isValidSecret = (secret: bytes, hashlock: bytes): bool => {
        return Crypto.keccak(secret) == hashlock;
    }

    

    const uniTransfer = (token_opt: option<address>, from_: address, to_: address, amountNat: nat): operation => {
        return UniversalTransfer.UniversalTransfer.uniTransfer(token_opt, from_, to_, amountNat);
    }

    const rescueFunds = (param: rescue_funds_param): list<operation> => {
        // 1. Modifier equivalent: onlyTaker
        onlyTaker(param.immutables);

        // 2. Modifier equivalent: onlyValidImmutables
        // onlyValidImmutables(s.immutables);

        // 3. Modifier equivalent: onlyAfter
        const rescueStartTime: timestamp = param.immutables.timelocks.deployedAt + param.rescueDelay;      
        onlyAfter(rescueStartTime);

        // 4. Main logic: Create the transfer operation
        const transfer_op: operation = uniTransfer(
            param.token_opt,
            Tezos.get_self_address(), // from: this contract
            Tezos.get_sender(),       // to: the taker who called this function
            param.amount
        );

        // 5. Create the Event Payload
        const event_payload: funds_rescued_event = {
            rescued_by: Tezos.get_sender(),
            token_rescued: param.token_opt,
            amount_rescued: param.amount
        };

        // 6. Create the Event Operation
        // We use a tag that clearly identifies the event, as per convention.
        const event_op: operation = Tezos.Next.Operation.emit("%FundsRescued", event_payload);
        
        // 7. Return BOTH operations in a list
        return list([transfer_op, event_op]);
    };


    
    // @entry
    // const dummy = (_ : unit, s : unit) : [list<operation>, unit] => {
    //     return [list([]), unit]
    // }

    type validSecretParams = {
        secret: bytes,
        hashlock: bytes
    }

    @entry
    const isvalidSecretEntry = (params: validSecretParams, storage: bool): [list<operation>, bool] => {
        
        // Check if secret matches hashlock by comparing keccak hashes
        const result: bool = Crypto.keccak(params.secret) == params.hashlock;
        return [list([]), result];
    }


    // @view
    // const is_valid_secret = (params: validSecretParams, _store: unit): bool => {
    //     const hash = Crypto.keccak(params.secret);
    //     return hash == params.hashlock;
    //     };

    
    
    
}

