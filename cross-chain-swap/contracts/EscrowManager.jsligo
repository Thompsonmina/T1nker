#import "Immutables.jsligo" "Immutables"
#import "UniversalTransfer.jsligo" "UniversalTransfer"
#import "BaseEscrow.jsligo" "BaseEscrow"



export namespace EscrowManager {

    
    
    // type escrow_maps:
    //  big_map<BaseEscrow.BaseEscrow.unique_escrow_id, BaseEscrow.BaseEscrow.escrow_state>; // escrow address

    type escrow_content = {
        escrow_state: BaseEscrow.BaseEscrow.escrow_state,
        escrow_type: BaseEscrow.BaseEscrow.escrow_type,
        rescue_delay: int
    }
    
    type escrow_map =
    big_map<BaseEscrow.BaseEscrow.immutables_hash, escrow_content>;

    type escrow_src_created_event = {
        immutables: Immutables.Immutables.immutables,
    };

    type escrow_dst_created_event = {
        immutables: Immutables.Immutables.immutables,
    };

    type storage = {
        escrow_map: escrow_map
    }
    type return_type = [list<operation>, storage];

    type create_src_params = {
        immutables: Immutables.Immutables.immutables,
        rescue_delay: int
    }

    type create_dst_params = {
        immutables: Immutables.Immutables.immutables,
        rescue_delay: int,
        src_cancellation_timestamp: timestamp
    }

    
    const escrow_exists_and_is_active = (escrow_map: escrow_map, escrow_id: BaseEscrow.BaseEscrow.immutables_hash): bool => {

        const escrow_content_opt: option<escrow_content> = Big_map.find_opt (escrow_id, escrow_map);

        return match(escrow_content_opt) {
            when(Some({escrow_state, escrow_type})): do {
                match(escrow_state) {
                    when(Active): true
                    when(_): false
                }
            }
            when(None): failwith("No Escrows exist that match the immutables hash")
        }
    }

    const onlyValidImmutables = (im: Immutables.Immutables.immutables, escrow_map: escrow_map): unit => {
        
        // escrow hash here is the hash of the immutables
        const escrow_id: BaseEscrow.BaseEscrow.immutables_hash = Immutables.Immutables.hash(im);
        const is_active: bool = escrow_exists_and_is_active(escrow_map, escrow_id);

        if (!is_active) {
            failwith("No Active Escrows exist that match the immutables hash");
        }
    
    }



    namespace EscrowSrcOperations {

        const _src_withdraw_to = (params: {secret: bytes, target: address, immutables: Immutables.Immutables.immutables}, escrow_map: escrow_map): list<operation> => {
        
            BaseEscrow.BaseEscrow.onlyValidSecret(params.secret, params.immutables);
            onlyValidImmutables(params.immutables, escrow_map);

            // sends back the token to the target (tez or fa2)
            const token_transfer_op: operation = UniversalTransfer.UniversalTransfer.uniTransfer(
                params.immutables.token,
                Tezos.get_self_address(),
                params.target,
                params.immutables.amount
            );

            // sends back the safety deposit to the taker
            const safety_deposit_transfer_op: operation = UniversalTransfer.UniversalTransfer.uniTransfer(
                None(),
                Tezos.get_self_address(),
                Tezos.get_sender(),
                params.immutables.safetyDeposit
            );

            return list([token_transfer_op, safety_deposit_transfer_op]);
        }
        
        const src_withdraw_to = (params: {secret: bytes, target: address, immutables: Immutables.Immutables.immutables}, escrow_map: escrow_map): return_type => {

            BaseEscrow.BaseEscrow.onlyTaker(params.immutables);
            BaseEscrow.BaseEscrow.onlyAfter(params.immutables.timelocks.srcWithdrawal);
            BaseEscrow.BaseEscrow.onlyBefore(params.immutables.timelocks.srcCancellation);
            
            const ops: list<operation> = _src_withdraw_to(params, escrow_map);
            return [ops, {escrow_map}];
        }

        const src_withdraw = (params: {secret: bytes, immutables: Immutables.Immutables.immutables}, escrow_map: escrow_map): return_type => {
        

            BaseEscrow.BaseEscrow.onlyTaker(params.immutables);
            BaseEscrow.BaseEscrow.onlyAfter(params.immutables.timelocks.srcWithdrawal);
            BaseEscrow.BaseEscrow.onlyBefore(params.immutables.timelocks.srcCancellation);
            
            const target: address = Tezos.get_sender();
            const new_params: {secret: bytes, target: address, immutables: Immutables.Immutables.immutables} = {secret: params.secret, target: target, immutables: params.immutables};
            const ops: list<operation> = _src_withdraw_to(new_params, escrow_map);

            return [ops, {escrow_map}];
            // emit Withdrawal(secret);
            
        }

        const src_public_withdraw = (params: {immutables: Immutables.Immutables.immutables}, escrow_map: escrow_map): return_type => {
            
            BaseEscrow.BaseEscrow.onlyAfter(params.immutables.timelocks.srcPublicWithdrawal);
            BaseEscrow.BaseEscrow.onlyBefore(params.immutables.timelocks.srcCancellation);

            const target: address = Tezos.get_sender();
            const new_params: {secret: bytes, target: address, immutables: Immutables.Immutables.immutables} = {secret: params.secret, target: target, immutables: params.immutables};
            const ops: list<operation> = _src_withdraw_to(new_params, escrow_map);

            return [ops, {escrow_map}];    

        }

        const _src_cancel = (params: {immutables: Immutables.Immutables.immutables}, escrow_map: escrow_map): list<operation> => {
        
            onlyValidImmutables(params.immutables, escrow_map);

            // sends back the token to the target (tez or fa2)
            const token_transfer_op: operation = UniversalTransfer.UniversalTransfer.uniTransfer(
                params.immutables.token,
                Tezos.get_self_address(),
                params.immutables.maker,
                params.immutables.amount
            );

            // sends back the safety deposit to the person who cancelled the escrow
            const safety_deposit_transfer_op: operation = UniversalTransfer.UniversalTransfer.uniTransfer(
                None(),
                Tezos.get_self_address(),
                Tezos.get_sender(),
                params.immutables.safetyDeposit
            );
        }

        const src_cancel = (params: {immutables: Immutables.Immutables.immutables}, escrow_map: escrow_map): return_type => {

            BaseEscrow.BaseEscrow.onlyTaker(params.immutables);
            BaseEscrow.BaseEscrow.onlyAfter(params.immutables.timelocks.srcCancellation);

            const ops: list<operation> = _src_cancel(params, escrow_map);
            return [ops, {escrow_map}];
        }

        const src_public_cancel = (params: {immutables: Immutables.Immutables.immutables}, escrow_map: escrow_map): return_type => {

            BaseEscrow.BaseEscrow.onlyAfter(params.immutables.timelocks.srcPublicCancellation);

            const ops: list<operation> = _src_cancel(params, escrow_map);
            return [ops, {escrow_map}];
        }

    }

    namespace EscrowDstOperations {

        const _dst_withdraw = (params: {secret: bytes, immutables: Immutables.Immutables.immutables}, escrow_map: escrow_map): list<operation> => {

            BaseEscrow.BaseEscrow.onlyValidSecret(params.secret, params.immutables);
            onlyValidImmutables(params.immutables, escrow_map);

            // sends the requested amount to the maker
            const token_transfer_op: operation = UniversalTransfer.UniversalTransfer.uniTransfer(
                params.immutables.token,
                Tezos.get_self_address(),
                params.immutables.maker,
                params.immutables.amount
            );

            // sends back the safety deposit to the taker
            const safety_deposit_transfer_op: operation = UniversalTransfer.UniversalTransfer.uniTransfer(
                None(),
                Tezos.get_self_address(),
                Tezos.get_sender(),
                params.immutables.safetyDeposit
            );

            // emit withdrawal(params.secret);

            return list([token_transfer_op, safety_deposit_transfer_op]);
        }

        const dst_withdraw = (params: {secret: bytes, immutables: Immutables.Immutables.immutables}, escrow_map: escrow_map): return_type => {

            BaseEscrow.BaseEscrow.onlyTaker(params.immutables);
            BaseEscrow.BaseEscrow.onlyAfter(params.immutables.timelocks.dstWithdrawal);
            BaseEscrow.BaseEscrow.onlyBefore(params.immutables.timelocks.dstCancellation);

            const ops: list<operation> = _dst_withdraw(params, escrow_map);
            return [ops, {escrow_map}];
        }

        const dst_public_withdraw = (params: {secret: bytes, immutables: Immutables.Immutables.immutables }, escrow_map: escrow_map): return_type => {

            BaseEscrow.BaseEscrow.onlyAfter(params.immutables.timelocks.dstPublicWithdrawal);
            BaseEscrow.BaseEscrow.onlyBefore(params.immutables.timelocks.dstCancellation);

            const ops: list<operation> = _dst_withdraw(params, escrow_map);
            return [ops, {escrow_map}];
        }

        const dst_cancel = (params: {immutables: Immutables.Immutables.immutables}, escrow_map: escrow_map): return_type => {

            BaseEscrow.BaseEscrow.onlyTaker(params.immutables);
            onlyValidImmutables(params.immutables, escrow_map);
            BaseEscrow.BaseEscrow.onlyAfter(params.immutables.timelocks.dstCancellation);

            const token_transfer_op: operation = UniversalTransfer.UniversalTransfer.uniTransfer(
                params.immutables.token,
                Tezos.get_self_address(),
                params.immutables.taker,
                params.immutables.amount
            );

            const safety_deposit_transfer_op: operation = UniversalTransfer.UniversalTransfer.uniTransfer(
                None(),
                Tezos.get_self_address(),
                Tezos.get_sender(),
                params.immutables.safetyDeposit
            );

            return [list([token_transfer_op, safety_deposit_transfer_op]), {escrow_map}];
        }
        
    }


    const _createSrcEscrow = (params: create_src_params, store: storage): return_type => {
        
        const immutables_hash: bytes = Immutables.Immutables.hash(params.immutables);

        const escrow_state: BaseEscrow.BaseEscrow.escrow_state = Active();
        const escrow_type: BaseEscrow.BaseEscrow.escrow_type = Source();

        
        const rescue_delay: int = params.rescue_delay;
        const new_escrow_map: escrow_map = Big_map.add(immutables_hash, {escrow_state, escrow_type, rescue_delay}, store.escrow_map);
        const new_store: storage = {escrow_map: new_escrow_map};

        const tez_sent: bool =  match(params.immutables.token) {
            when(Some(token)): do {
                // If the token is an fa2(erc20) the contract needs to be approved
                return false
            }
            when(None): do {
                // check that the appropiate amount of tez is sent
                const tez_amount: tez = params.immutables.amount * 1mutez;
                const tez_sent: tez = Tezos.get_amount();
                if (tez_sent != tez_amount) {
                    failwith("Incorrect amount of tez sent");
                }
                return true
            }
        }
        
         const escrow_src_created_event: escrow_src_created_event = {
            immutables: params.immutables
        };

        // 6. Create the Event Operation
        // We use a tag that clearly identifies the event, as per convention.
        const event_op: operation = Tezos.Next.Operation.emit("%EscrowSrcCreated", escrow_src_created_event);
        

        if (!tez_sent) {
            // If the token is an fa2(erc20) the contract needs to be approved to send the token
            // to itself
            const transfer_op: operation = UniversalTransfer.UniversalTransfer.uniTransfer(
                params.immutables.token,
                Tezos.get_sender(), // The maker sends the token on escrow creation
                Tezos.get_self_address(),
                params.immutables.amount
            );

            return [list([transfer_op, event_op]), new_store];
        }
        // maker sends funds to escrow and then contract broadcasts escrow creation
        return [list([event_op]), new_store];
    }

    const _createDstEscrow = (params: create_dst_params, store: storage): return_type => {

        // check that safety deposit is sent
        // then check if the amount to be escrowed is tez or fa2

        const tez_sent: bool =  match(params.immutables.token) {
            when(Some(token)): do {
                // we only need to check that safety deposit is sent no additional amount is needed in tez
                const safety_deposit: tez = params.immutables.safetyDeposit * 1mutez;
                const deposit_sent: tez = Tezos.get_amount();

                if (deposit_sent != safety_deposit) {
                    failwith("Incorrect amount of safety deposit sent");
                }
                return false
            }

            when(None): do {
                // check that the appropiate amount of tez is sent when fund to be escrowed is tez

                const safety_deposit: tez = params.immutables.safetyDeposit * 1mutez;
                const tez_amount: tez = params.immutables.amount * 1mutez;
                const total_amount: tez = safety_deposit + tez_amount;

                const tez_sent: tez = Tezos.get_amount();
                if (tez_sent != total_amount) {
                    failwith("Incorrect amount of tez sent");
                }
                return true
            }
        }

        // set deployed timestamp

        const new_timelocks = {...params.immutables.timelocks, deployedAt: Tezos.get_now()};
        const dest_immutables = {...params.immutables, timelocks: new_timelocks};


        // check that the escrow cancellation will start not later than the cancellation time on the source chain.
        if (params.immutables.timelocks.dstCancellation > params.src_cancellation_timestamp) {
            failwith("Invalid creation time");
        }   


        // create a new escrow entry and update contract state
        const escrow_id: BaseEscrow.BaseEscrow.immutables_hash = Immutables.Immutables.hash(dest_immutables);

        const escrow_state: BaseEscrow.BaseEscrow.escrow_state = Active();
        const escrow_type: BaseEscrow.BaseEscrow.escrow_type = Destination();

        const rescue_delay: int = params.rescue_delay;

        const new_escrow_map: escrow_map = Big_map.add(escrow_id, {escrow_state, escrow_type, rescue_delay}, store.escrow_map);
        const new_store: storage = {escrow_map: new_escrow_map};


        if (!tez_sent) {
            // If the token is an fa2(erc20) the contract needs to be approved to send the token
            // to itself
            const transfer_op: operation = UniversalTransfer.UniversalTransfer.uniTransfer(
                params.immutables.token,
                Tezos.get_sender(), // The maker sends the token on escrow creation
                Tezos.get_self_address(),
                params.immutables.amount
            );

            const escrow_dst_created_event: escrow_dst_created_event = {
                immutables: dest_immutables,
            };

            const event_op: operation = Tezos.Next.Operation.emit("%EscrowDstCreated", escrow_dst_created_event);

            return [list([transfer_op, event_op]), new_store];
        }
    }
    
    type rescue_funds_param = {
        immutables: Immutables.Immutables.immutables,
        rescueDelay: int,
        token_opt: option<address>,
        amount: nat
    };

    // rescueFunds event payload
    type funds_rescued_event = {
        rescued_by: address,
        token_rescued: option<address>,
        amount_rescued: nat
    };

    const rescueFunds = (param: rescue_funds_param): list<operation> => {
        // 1. Modifier equivalent: onlyTaker
        BaseEscrow.BaseEscrow.onlyTaker(param.immutables);

        // 2. Modifier equivalent: onlyValidImmutables
        // onlyValidImmutables(s.immutables);

        // 3. Modifier equivalent: onlyAfter
        const rescueStartTime: timestamp = param.immutables.timelocks.deployedAt + param.rescueDelay;      
        BaseEscrow.BaseEscrow.onlyAfter(rescueStartTime);

        // 4. Main logic: Create the transfer operation
        const transfer_op: operation = UniversalTransfer.UniversalTransfer.uniTransfer(
            param.token_opt,
            Tezos.get_self_address(), // from: this contract
            Tezos.get_sender(),       // to: the taker who called this function
            param.amount
        );

        
        const event_payload: funds_rescued_event = {
            rescued_by: Tezos.get_sender(),
            token_rescued: param.token_opt,
            amount_rescued: param.amount
        };

        const event_op: operation = Tezos.Next.Operation.emit("%FundsRescued", event_payload);
        
        // 7. Return BOTH operations in a list
        return list([transfer_op, event_op]);
    };


    @entry
    const createSrcEscrow = (params: create_src_params): return_type => {
        return _createSrcEscrow(params, store);
    }







} 